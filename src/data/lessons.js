export const lessons = [
    {
        id: 1,
        title: "مدخل إلى البرمجة والخوارزميات",
        hasExercises: false,
        content: `
## أنواع الآلات
---
1. **الآلات ذات البرامج الثابتة**: 
   - لا يمكن وضع برامج لها.
   - مثال: نول الخياطة (يعمل على برنامج ثابت، يعطي نتيجة واحدة فقط).

2. **الآلات القابلة للبرمجة**: 
   - آلات حديثة يمكن أن تنفذ مدخلات متعددة.
   - تحتاج إلى لغات برمجة خاصة بها.
   - تختلف لغات البرمجة من آلة إلى أخرى.

## بنية الآلة القابلة للبرمجة
---
تتكون الآلة القابلة للبرمجة من وحدات مختلفة تعمل معاً لتنفيذ البرامج.

![structure of programmable machine](https://ik.imagekit.io/qkzwdg8a3/img-spm.jpg)

### المكونات الرئيسية:
1. **الذاكرة الرئيسية**: تتكون من نوعين أساسيين:
   - **ذاكرة الوصول العشوائي (RAM)**: تستخدم لتخزين البيانات والبرامج التي يعمل عليها الحاسوب حالياً، وتُفقد محتوياتها عند انقطاع التيار الكهربائي.
   - **ذاكرة القراءة فقط (ROM)**: تحتفظ بالتعليمات الأساسية لتشغيل الحاسوب ولا تُفقد محتوياتها عند انقطاع التيار.
2. **وحدة المعالجة المركزية (CPU)**: وهي "عقل" الحاسوب الذي يقوم بتنفيذ العمليات الحسابية والمنطقية، وتتواصل مباشرة مع الذاكرة الرئيسية.
3. **أجهزة التخزين الثانوية**: مثل الذاكرة الفلاشية، والقرص الصلب، والأقراص المدمجة (CD/DVD)، وتستخدم لتخزين البيانات بشكل دائم.
4. **أجهزة الإدخال**: مثل الفأرة ولوحة المفاتيح، وتستخدم لإدخال البيانات إلى الحاسوب.
5. **أجهزة الإخراج**: مثل الشاشة والطابعة، وتستخدم لعرض النتائج والمعلومات من الحاسوب.

## أجيال لغات البرمجة
---
### الجيل الأول
**لغة المجمع (Assembly Language)**
- تعرّف من قبل الشركة المصنعة.
- تختلف باختلاف الآلة.
- غير عملية للتطوير المباشر من قبل الإنسان.

### الجيل الثاني
**اللغات الإجرائية (Procedural/Structure Language)**
- تعتمد على فكرة الإجراءات (التوابع).
- تسمح بإعادة استخدام التعليمات البرمجية.
- أمثلة: Fortran، Pascal، Basic، C.

### الجيل الثالث
**اللغات غرضية التوجه (Object Oriented Programming - OOP)**
- تعتمد على فكرة الصفوف (Classes) والأغراض (Objects).
- أمثلة: C#، Java.

### الجيل الرابع
**اللغات التصريحية (Declarative Language)**
- أشهرها SQL المستخدمة في قواعد البيانات.
- تركز على توصيف المهمة دون توضيح خطوات التنفيذ.

### الجيل الخامس
**لغات الذكاء الاصطناعي (AI Language)**
- يحل الحاسب المسألة دون تدخل المبرمج.
- تعتمد على الاستدلال باستخدام المنطق.
- أمثلة: Prolog، LISP.

> [warning]
> ### ملاحظة
> تعتبر لغة C++ بين الجيلين الثاني والثالث.

## مدخل إلى الخوارزميات
---
### الفرق بين الخوارزمية والبرنامج

**الخوارزمية:**
- مجموعة من الخطوات الواضحة والدقيقة لحل مشكلة.
- موجهة للإنسان.
- مرتبة ومنتهية ولها زمن تنفيذ محدود.
- مكتوبة بلغة خوارزميات (لا يفهمها الحاسب).

**البرنامج:**
- مجموعة من التعليمات المكتوبة بلغة برمجة.
- موجه للحاسب.
- مكتوب بلغة برمجة (مثل C، ++C، #C).
- في النهاية يتحول إلى لغة الآلة.

### أشكال كتابة الخوارزميات
1. **لغة نصية (Pseudocode)**: 
   - تكتب باللغة العربية أو الإنجليزية بشكل هيكلي.
2. **لغة بيانية/مخطط تدفقي (Flowchart)**: 
   - تكتب باستخدام المخطط الزمني.
   - تعتمد على الرسوم البيانية.

## أنواع خطوات كتابة الخوارزمية
---
### 1. القراءة (الدخل)
- خطوة لإدخال شيء من خارج الآلة (من المستخدم).
- بعدها يجب أن يأتي متحول فقط (لأن الدخل ليس ثابتاً).
- مثال: \`read x\`.

### 2. الكتابة (الخرج)
- تعرض قيمة المتحول أو نتيجة صيغة حسابية.
- مثال: \`write x\` (يعرض قيمة x وليس الحرف x).

### 3. الإسناد
- يحسب قيمة الطرف الأيمن ويسندها إلى المتحول في الطرف الأيسر.
- تأخذ رمز \`=\` أو \`←\`.
- مثال: \`z ← x + y\` (إسناد مجموع x + y إلى z).

### 4. الشرط
**الشرط البسيط (if)**
\`\`\`
if (condition)
    block of statements
\`\`\`
ينفذ التعليمات في حال تحقق الشرط فقط.

**الشرط مع البديل (if-else)**
\`\`\`
if (condition)
    block of statements 1
else
    block of statements 2
\`\`\`
يناقش حالتين فقط.

**الشرط المتعدد (if-else if-else)**
\`\`\`
if (condition 1)
    block of statements 1
else if (condition 2)
    block of statements 2
else
    block of statements 3
\`\`\`
يمكن مناقشة أكثر من حالتين.

### 5. التكرار
- ينفذ مجموعة من الخطوات طالما بقي الشرط محققا.
\`\`\`
while (condition)
    block of statements 
\`\`\`

> ### قواعد
> - يجب وضع خطوات تضمن التعديل على قيمة أحد المتحولات في الشرط.
> - إذا لم يتم التعديل، تصبح الحلقة غير منتهية.

## مفاهيم أساسية في الخوارزمية والبرمجة
---
### 1. الثابت (Constant)
- قيمة ثابتة من البداية إلى نهاية البرنامج.
- أمثلة: أرقام (0، 1، 2)، حرف ('S')، نص ("Hello")، قيمة منطقية (true، false).
- الحرف الواحد يكتب ضمن علامات اقتباس فردية (' ').
- سلسلة المحارف تكتب ضمن علامات اقتباس مزدوجة (" ").

### 2. المتغيرات (Variables)
- قيمة لحظية قابلة للتغيير.
- لا تتغير إلا بعملية واضحة يقوم بها المبرمج.
- لها اسم ونوع محدد.
- أمثلة: x، y، z أو أي حرف أو سلسلة محارف.
- شروط أسماء المتغيرات: ألا تبدأ برقم، رمز خاص، أو اسم محجوز.

### 3. الصيغ الحسابية
- مزيج من المتغيرات والثوابت والعمليات الحسابية والمنطقية.
- مثال: \`[y - 2 * (3 + x)]\`.
- يجب مراعاة أولوية العمليات الحسابية:
  1. الأس والجذر.
  2. الأقواس.
  3. الضرب والقسمة.
  4. الجمع والطرح.

## أمثلة تطبيقية
---
### مثال 1: حساب مساحة ومحيط مربع
\`\`\`
read x
s ← x^2
write s
l ← 4x
write l
\`\`\`
### مثال 2: التحقق من إشارة عدد
\`\`\`
read x
if (x > 0)
    write "positive"
else if  (x < 0)
    write "negative"
else
    write "zero"
\`\`\`
### مثال 3: معرفة عدد خانات عدد موجب
\`\`\`
read x
if (x < 10)
    write "one place"
else if  (x < 100)
    write "two places"
else if  (x < 1000)
    write "three places"
else
    write "four places and more"
\`\`\`
### مثال 4: طباعة الأعداد من 1 إلى 100
\`\`\`
x ← 1
while (x ≤ 100)
    write x
    x ← x + 1
\`\`\`

## المخطط التدفقي (Flowchart)
---
المخطط التدفقي هو طريقة بيانية (رسومية) لتمثيل الخوارزمية. يوضح الجدول التالي العناصر الأساسية للمخطط:

| الخطوة | لغة نصية | لغة رسومية (تدفقية) |
|--------|----------|----------------------|
| البداية والنهاية | البداية / النهاية |  ![oval shape](https://ik.imagekit.io/qkzwdg8a3/tr:w-0.4/img-oval.jpg) |
|  والكتابة | اقرأ / اكتب | ![parallelogram shape](https://ik.imagekit.io/qkzwdg8a3/tr:w-0.4/img-parallelogram.jpg)   |
| إسناد / عملية حسابية  | ← / + - % / true | ![rectangular shape](https://ik.imagekit.io/qkzwdg8a3/tr:w-0.4/img-rectangular.jpg) |
| الشرط | إذا | ![condition shape](https://ik.imagekit.io/qkzwdg8a3/img-condition.jpg)  |
| التكرار | طالما | ![loop shape](https://ik.imagekit.io/qkzwdg8a3/img-loop.jpg)  |

> [warning]
> ### ملاحظات مهمة:
> - الأسهم تربط بين الأشكال المختلفة لتحديد مسار التنفيذ.
> - الشكل العام للخوارزمية:
بداية ←  مجموعة خطوات ←  نهاية.

### أمثلة على المخططات التدفقية:

1. **التحقق من إشارة عدد**:
![number sign algorithm](https://ik.imagekit.io/qkzwdg8a3/img-nsf.jpg)

**شرح المخطط التدفقي**
- البداية
- قراءة قيمة x من المستخدم
- التحقق إذا كان x > 0:
   - إذا كانت الإجابة "نعم": طباعة "موجب"
   - إذا كانت الإجابة "لا": طباعة "سالب"
- النهاية

2. **جمع عددين**:
![sumation algorithm](https://ik.imagekit.io/qkzwdg8a3/tr:w-0.7/img-sf.jpg)

**شرح المخطط التدفقي**
- البداية
- قراءة قيمتي x و y من المستخدم
- طباعة مجموع x + y
- النهاية

3. **طباعة الأعداد من 1 إلى عدد يدخله المستخدم**:
![print numbers algorithm](https://ik.imagekit.io/qkzwdg8a3/img-cf.jpg)

**شرح المخطط التدفقي**
- البداية
- قراءة قيمة x من المستخدم
- تعيين قيمة i = 1
- التحقق إذا كان i ≤ x:
   - إذا كانت الإجابة "نعم": طباعة قيمة i، ثم زيادة i بمقدار 1، والعودة للتحقق مرة أخرى
   - إذا كانت الإجابة "لا": الانتقال إلى النهاية
`
    },
    {
        id: 2,
        title: "أساسيات لغة ++C",
        hasExercises: true,
        content: `
## مراحل تنفيذ برنامج ++C
---
1. **Precompiling**: تنفيذ التعليمات التوجيهية.
2. **Compiling**: التأكد من صحة وسلامة تعليمات البرنامج.
3. **Linking**: الربط مع المكتبات.
4. **Run**: تنفيذ خطوات البرنامج.

## أنواع الأخطاء في البرمجة
---
1. **أخطاء منطقية (Logical Errors)**: خطأ غير مقصود من المبرمج (قصد شيء وكتب شيء آخر).
2. **أخطاء وقت التشغيل (Runtime Errors)**: خطأ يحدث أثناء التنفيذ مثل القسمة على صفر.
3. **أخطاء بنيوية (Syntax Errors)**: خطأ في قواعد اللغة (يكتشفه المترجم قبل التنفيذ).
4. **أخطاء الربط (Linking Errors)**: تظهر في مرحلة الربط مثل استخدام تعليمة دون تضمين مكتبتها.

## خصائص لغة ++C
---
- غير حساسة للفراغات أو الأسطر.
- معظم التعليمات تنتهي بـ \`;\`.
- حساسة للحروف الكبيرة والصغيرة.

## بنية البرنامج في ++C
---
\`\`\`cpp
#include <iostream>
using namespace std;

int main() {
    // مجموعة تعليمات
    return 0;
}
\`\`\`

### شرح البنية:
1. **\`<include <iostream#\`**:
   - \`#\` تعليمة توجيهية يقرأها الـ precompiler.
   - \`include\` تعني تضمين المكتبة.
   - \`iostream\` مكتبة معيارية للتعامل مع الدخل والخرج.

2. **\`;using namespace std\`**:
   - تختصر كتابة \`std::\` قبل كل تعليمة من مكتبة iostream.
   - \`namespace\` تقسيم منطقي لتجنب تعارض المكتبات.

3. **\`()int main\`**:
   - \`main\` هو التابع الرئيسي ومنه يبدأ تنفيذ البرنامج.
   - \`int\` تشير إلى أن التابع سيرد قيمة من نوع integer.
   - \`;return 0\` تدل على أن البرنامج انتهى دون أخطاء.

## المتغيرات في ++C
---
### خصائص المتغيرات:
1. حجم محدد في الذاكرة (ثابت لا يتغير).
2. نوع يحدد القيم التي يمكن تخزينها (ثابت لا يتغير).
3. اسم للوصول إليه.

> ### قواعد تسمية المتغيرات
> **يجوز**:
> - استخدام الحروف الإنجليزية.
> - استخدام الرمزين \`_\` و \`$\`.
> - استخدام أرقام في المنتصف أو النهاية.
>
> **لا يجوز**:
> - استخدام كلمات محجوزة في اللغة.
> - وجود فراغات (space).
> - استخدام رموز خاصة (باستثناء \`_\` و \`$\`).
> - استخدام عمليات حسابية أو منطقية.
> - البدء برقم.

### طرق تسمية متغير بعدة كلمات:
1. **طريقة camelCase**: (الكلمات متصلة والحرف الأول ابتداءاً من الكلمة الثانية كبير).
   - مثال: wayOfWriting.
   - تستخدم عادة لتسمية المتغيرات والتوابع وخصائص الغرض.
2. **طريقة SCREAMING_SNAKE_CASE**: (الكلمات بحروف كبيرة ومفصولة بـ \`_\`).
   - مثال: WAY_OF_WRITING.
   - تستخدم في تسمية الثوابت.
3. **طريقة PascalCase**: (الكلمات متصلة والحرف الأول من كل كلمة كبير).
   - مثال: WayOfWriting.
   - تستخدم عادة لتسمية الصفوف.

## أنماط المتغيرات في ++C
---
| النمط | الحجم بالبايت | المجال | شرح |
|-------|--------------|--------|------|
| char | 1 | 0 ← 255 | محرف واحد |
| short | 2 | -32768 ← 32767 | أعداد صحيحة فقط |
| int/long | 4 | أكبر من short | أعداد صحيحة فقط |
| float | 4 | 7 أرقام بعد الفاصلة | أعداد صحيحة وعشرية |
| double | 8 | 15 رقم بعد الفاصلة | أعداد صحيحة وعشرية |
| bool | 1 | true = 1 أو false = 0 | قيمة منطقية |

### تعريف المتغيرات:
\`\`\`cpp
variable_type variable_name; // تعريف فقط
variable_type variable_name = value; // تعريف مع إسناد قيمة ابتدائية
\`\`\`

## الثوابت في ++C
---
يمكن تعريف الثوابت بطريقتين:

1. **باستخدام \`const\`**:
\`\`\`cpp
const constant_type constant_name = value;
\`\`\`

2. **باستخدام \`define#\`**:
\`\`\`cpp
#define constant_name value
\`\`\`

> [warning]
> ### ملاحظة
> عند استخدام \`define#\` لا نستخدم \`;\` و \`=\`.

## العمليات في لغة ++C
---
### عمليات المقارنة
- \`==\` : يساوي (للمقارنة وليست للإسناد)
- \`=!\` : لا يساوي
- \`>\` : أصغر من
- \`<\` : أكبر من
- \`=>\` : أصغر من أو يساوي
- \`=<\` : أكبر من أو يساوي

تُستخدم للمقارنة بين الثوابت أو المتغيرات أو الصيغ الحسابية. جميع عمليات المقارنة تعيد قيمة منطقية (\`true\` أو \`false\`).

### العمليات المنطقية
- \`&&\` (and): تعيد \`true\` فقط إذا كان الشرطان صحيحين
- \`||\` (or): تعيد \`true\` إذا كان أحد الشرطين صحيحًا على الأقل
- \`!\` (not): تقلب القيمة المنطقية

جدول الحقيقة للعمليات المنطقية

| a && b | a \\|\\| b | b | a |
|:---:|:---:|:---:|:---:|
| true | true | true | true |
| false | false | false | false |
| false | true | true | false |
| false | true | false | true |

### العمليات الحسابية
---
- الجمع: \`+\`.
- الطرح: \`-\`.
- الضرب: \`*\`.
- القسمة الصحيحة: \`/\` (تعيد عدد صحيح فقط مثل \`7/3 = 2\`).
- باقي القسمة: \`%\`.

> ### قاعدة
> للحصول على نتيجة عشرية في القسمة، يجب أن يكون أحد المعاملات على الأقل من النوع العشري:
> \`\`\`cpp
> 7.0/2   // يعطي 3.5
> 7/2.0   // يعطي 3.5
> \`\`\`

## الإسناد المركب
---
\`\`\`cpp
i = i + 1  ⟺  i += 1
i = i - 1  ⟺  i -= 1
i = i * 1  ⟺  i *= 1
i = i / 1  ⟺  i /= 1
i = i % 1  ⟺  i %= 1
\`\`\`

## عمليات الزيادة والنقصان
---
- \`++i\`: زيادة بمقدار 1 ثم استخدام القيمة.
- \`i++\`: استخدام القيمة ثم زيادة بمقدار 1.

**مثال على الإختلاف**:
\`\`\`cpp
// الطريقة الأولى
int x = 4;
int y = x++;  // y=4, x=5

// الطريقة الثانية
int x = 4;
int y = ++x;  // y=5, x=5
\`\`\`

## تعليمات الإدخال والإخراج
---
### الإدخال (القراءة):
\`\`\`cpp
cin >> x >> y;  // قراءة قيمتين متتاليتين

// يعادل
cin >> x;
cin >> y;
\`\`\`

### الإخراج (الكتابة):
\`\`\`cpp
cout << x << y;  // طباعة قيمتين متتاليتين

// يعادل
cout << x;
cout << y;
\`\`\`

### أمثلة للإخراج:
- طباعة النص كما هو: \`;"cout << "x\` يعطي بالخرج \`x\`.
- طباعة قيمة متغير: \`;int x = 3; cout << x\`  يعطي بالخرج 3.
- طباعة سطر جديد: \`;cout << endl\` أو<br>
\`;"cout << "\\n\`.
- طباعة مسافة أفقية: 
\`;"cout << "\\t\`.
- طباعة رموز خاصة:
  - لطباعة \`\\\`:
  \`"\\\\"\`.
  - لطباعة \`'\`:
  \`"'\\"\`.
  - لطباعة \`"\`: 
  \`""\\"\`.
  - لحذف حرف قبلها:
  \`"b\\"\`.
  - محرف خالي (القيمة الأولية لأي محرف): \`"0\\"\`.
`
    },
    {
        id: 3,
        title: "بنى التحكم",
        hasExercises: true,
        content: `
## بنى التحكم الشرطية
---
### جملة if
\`\`\`cpp
if (condition) {
    // التعليمات التي تنفذ إذا كان الشرط صحيحاً
}
\`\`\`

**مثال**:
\`\`\`cpp
if (20 > 18) {
  cout << "20 is greater than 18";
}
\`\`\`

<div dir="ltr">
  <h3>Output</h3>
  <pre>
    <code>
20 is greater than 18
    </code>
  </pre>
</div>

> ### قواعد مهمة
> - الأقواس المعقوفة \`{}\` إجبارية في حال وجود أكثر من تعليمة.
> - للمقارنة نستخدم \`==\` وليس \`=\`.
> - في معظم لغات البرمجة يعتبر الإسناد داخل الشرط error syntax ولكن في لغة ++C لا يعتبر خطأ، بل يعتبر من الأخطاء الصعب إيجادها.  
> - أي رقم غير الصفر يعتبر \`true\`، والصفر يعتبر \`false\`.

### جملة if-else
\`\`\`cpp
if (condition) {
    // التعليمات التي تنفذ إذا كان الشرط صحيحاً
} else {
    // التعليمات التي تنفذ إذا كان الشرط خاطئاً
}
\`\`\`

**مثال**:
\`\`\`cpp
int time = 20;
if (time < 18) {
  cout << "Good day";
} else {
  cout << "Good evening";
}
\`\`\`

<div dir="ltr">
  <h3>Output</h3>
  <pre>
    <code>
Good evening
    </code>
  </pre>
</div>

> ### معلومة هامة
> في لغة ++C، يُعتبر العامل الثلاثي (ternary) أو العامل الشرطي ( ؟ : ) أقصر صيغة لكتابة العبارات الشرطية. يمكن استخدامه كعبارة شرطية مضمنة بدلاً من if-else لتنفيذ كود شرطي معين.
> مثال:
> \`\`\`cpp 
> 5 > 6 ? "5 bigger than 6" : "5 smaller than 6";
> \`\`\`

### جملة if-else if-else
\`\`\`cpp
if (condition_1) {
  // التعليمات التي تنفذ إذا كان الشرط الأول صحيحاً
} else if (condition_2) {
  // التعليمات التي تنفذ إذا كان الشرط الأول خاطئاً والشرط الثاني صحيحاً
} else {
  // التعليمات التي تنفذ إذا كان الشرطين الأول والثاني خاطئين
}
\`\`\`

**مثال**:
\`\`\`cpp
int time = 22;
if (time < 10) {
  cout << "Good morning";
} else if (time < 20) {
  cout << "Good day";
} else {
  cout << "Good evening";
}
\`\`\`

<div dir="ltr">
  <h3>Output</h3>
  <pre>
    <code>
Good evening
    </code>
  </pre>
</div>

### جملة switch
تستخدم للاختيار من بين عدة خيارات:

\`\`\`cpp
switch (variable) {
    case value_1:
        // تعليمات الحالة الأولى
        break;
    case value_2:
        // تعليمات الحالة الثانية
        break;
    default:
        // تعليمات الحالة الافتراضية (مثل else)
}
\`\`\`

**مثال**:
\`\`\`cpp
int day = 2;
switch (day) {
  case 1:
    cout << "Monday";
    break;
  case 2:
    cout << "Tuesday";
    break;
  case 3:
    cout << "Wednesday";
    break;
  default:
    cout << "Sunday";
}
\`\`\`

<div dir="ltr">
  <h3>Output</h3>
  <pre>
    <code>
Tuesday
    </code>
  </pre>
</div>

> [warning]
> ### ملاحظات:
> - \`switch\` تعمل فقط مع المتغيرات من نوع \`int\` أو \`char\`.
> - استخدام \`break\` ضروري لمنع تنفيذ الحالات التالية.
> - \`default\` هي الحالة الافتراضية (تماثل \`else\`).

## الحلقات التكرارية (Loops)
---
### حلقة while
تستمر بالتنفيذ طالما الشرط صحيح:
\`\`\`cpp
while (condition) {
    // التعليمات التي ستتكرر
}
\`\`\`

**المخطط التدفقي:**
![while loop](https://ik.imagekit.io/qkzwdg8a3/img-while.jpg)

**مثال: طباعة الأعداد من 1 إلى n**
\`\`\`cpp
#include <iostream>
using namespace std;
int main() {
    int n, x = 1;
    cin >> n; // فرضاً 5
    while (x <= n) {
        cout << x << endl;
        x++;
    }
    return 0;
}
\`\`\`

<div dir="ltr">
  <h3>Output</h3>
  <pre>
    <code>
1\n2\n3\n4\n5
    </code>
  </pre>
</div>

### حلقة do-while
تنفذ التعليمات مرة واحدة على الأقل ثم تفحص الشرط:
\`\`\`cpp
do {
    // التعليمات التي ستتكرر
} while (condition);
\`\`\`

**المخطط التدفقي:**
![do while loop](https://ik.imagekit.io/qkzwdg8a3/img-do-while.jpg)

**مثال: طباعة الأعداد من 1 إلى n**
\`\`\`cpp
#include <iostream>
using namespace std;
int main() {
    int n, x = 1;
    cin >> n; // فرضاً 5
    do {
        cout << x << endl;
        x++;
    } while (x <= n);
    return 0;
}
\`\`\`

<div dir="ltr">
  <h3>Output</h3>
  <pre>
    <code>
1\n2\n3\n4\n5
    </code>
  </pre>
</div>

### حلقة for
تستخدم للتكرار لعدد محدد من المرات:
\`\`\`cpp
for (initialize; condition; modify) { // تهيئة ; شرط ; تعديل
    // التعليمات التي ستتكرر
}
\`\`\`

**المخطط التدفقي**
![for loop](https://ik.imagekit.io/qkzwdg8a3/img-for.jpg)

**مثال: طباعة الأعداد من 1 إلى n**
\`\`\`cpp
#include <iostream>
using namespace std;
int main() {
    int n;
    cin >> n; // فرضاً 5
    for (int i = 1; i <= n; i++) {
        cout << i << endl;
    }
    return 0;
}
\`\`\`

<div dir="ltr">
  <h3>Output</h3>
  <pre>
    <code>
1\n2\n3\n4\n5
    </code>
  </pre>
</div>

## التحكم بمسار الحلقات
---
### تعليمة continue
تتخطى الدورة الحالية وتنتقل للدورة التالية:
\`\`\`cpp
#include <iostream>
using namespace std;
int main() {
    int n;
    cin >> n; // فرضاً 5
    for (int x = 1; x <= n; x++) {
        if (x == 3)
            continue;
        cout << x << endl;
    }
    return 0;
}
\`\`\`

<div dir="ltr">
  <h3>Output</h3>
  <pre>
    <code>
1\n2\n4\n5
    </code>
  </pre>
</div>

### تعليمة break
تخرج من الحلقة بشكل كامل:
\`\`\`cpp
#include <iostream>
using namespace std;
int main() {
    int n;
    cin >> n; // فرضاً 5
    for (int x = 1; x <= n; x++) {
        if (x == 3)
            break;
        cout << x << endl;
    }
    return 0;
}
\`\`\`

<div dir="ltr">
  <h3>Output</h3>
  <pre>
    <code>
1\n2
    </code>
  </pre>
</div>

> [warning]
> ### ملاحظات إضافية:
> - يمكن استخدام أكثر من تعليمة في حلقة \`for\` بفصلها بفواصل:
> \`\`\`cpp
> for (int i = 0, j = 10; i <= 10; i++, j--)
> \`\`\`
> - يمكن تعشيش الحلقات والشروط داخل بعضها البعض.
> - تجنب استخدام تعليمة \`goto\` لأنها تجعل الكود صعب القراءة والفهم.

> [success]
> ### نصائح وإرشادات مهمة
> **متى نستخدم كل نوع من الحلقات:**
> - **حلقة while**: عندما لا نعرف مسبقاً عدد مرات التكرار.
> - **حلقة do-while**: عندما نريد تنفيذ التعليمات مرة واحدة على الأقل.
> - **حلقة for**: عندما نعرف عدد المرات التي نريد تكرارها.
>
> **أخطاء شائعة:**
> - الخلط بين \`=\` (للإسناد) و\`==\` (للمقارنة) في جمل الشرط.
> - نسيان كلمة \`break\` في تعليمة \`switch\`.
> - نسيان وضع الفاصلة المنقوطة \`;\` بعد كل تعليمة.
> - نسيان الأقواس المعقوفة \`{}\` في الحلقات والشروط عند وجود أكثر من تعليمة.
`
    },
    {
        id: 4,
        title: "المصفوفات",
        hasExercises: true,
        content: `
## المصفوفات الأحادية
---
المصفوفة هي مجموعة من العناصر المتجاورة في الذاكرة، جميعها من نفس النوع، ويمكن الوصول إليها باستخدام مؤشر (index) كما في الشكل الآتي:

![array structure](https://ik.imagekit.io/qkzwdg8a3/img-sar.jpg)

### تعريف المصفوفة الأحادية
\`\`\`cpp
int arr[5]; // مصفوفة من 5 عناصر من نوع int
\`\`\`

### خصائص المصفوفة
1. عدد العناصر ثابت ولا يتغير بعد التعريف.
2. جميع العناصر من نفس النوع (int, float, char, ...).
3. يتم تخزينها بشكل متتالي في الذاكرة.
4. يبدأ ترقيم عناصرها من الصفر (0) وينتهي عند (عدد العناصر - 1).

### طرق تعريف وتهيئة المصفوفات
\`\`\`cpp
// طريقة 1: تعريف ثم إسناد
int arr[5];
arr[0] = 1;
arr[1] = 3;
arr[2] = 5;
arr[3] = 7;
arr[4] = 6;

// طريقة 2: تعريف وإسناد في نفس الوقت
int arr[5] = {1, 3, 5, 7, 6};

// طريقة 3: بدون تحديد الحجم (يتم حسابه تلقائياً)
int arr[] = {1, 3, 5, 7, 6}; // سيكون الحجم 5
\`\`\`

### إدخال وإخراج المصفوفات
\`\`\`cpp
// إدخال عناصر المصفوفة
for (int i = 0; i < 5; i++) {
    cin >> arr[i];
}
// فرضا تم ادخال 5 عناصر
// إخراج (طباعة) عناصر المصفوفة
for (int i = 0; i < 5; i++) {
    cout << arr[i] << " ";
}
\`\`\`

<div dir="ltr">
  <h3>Output</h3>
  <pre>
    <code>
1 2 3 4 5
    </code>
  </pre>
</div>

> [warning]
> ### ملاحظات هامة
> - لا يمكن إدخال أو إخراج المصفوفة كاملة بتعليمة واحدة.
> - الوصول إلى عنصر خارج حدود المصفوفة (مثل \`arr[5]\` في مصفوفة حجمها 5) قد يؤدي إلى:
>   1. خطأ في بعض لغات البرمجة.
>   2. قراءة أو تعديل قيمة في ذاكرة ليست مخصصة للمصفوفة.
>   3. تغيير قيمة متغير آخر إذا كان مخزنًا في هذا المكان.

## المصفوفات الثنائية
---
المصفوفة الثنائية هي مصفوفة من المصفوفات، أو يمكن القول كجدول من الصفوف والأعمدة كما هو مبين في الشكل التالي:

![array structure](https://ik.imagekit.io/qkzwdg8a3/img-da.jpg)

### تعريف المصفوفة الثنائية
\`\`\`cpp
int arr[3][5]; // مصفوفة من 3 صفوف و5 أعمدة
\`\`\`

### طرق تهيئة المصفوفات الثنائية
\`\`\`cpp
// طريقة 1: تعريف وتهيئة في نفس الوقت
int arr[3][5] = {
    {1, 2, 3, 15, 7},
    {8, 9, 0, 0, 0},
    {3, 11, 4, 6, 9}
};

// طريقة 2: إذا لم نضع قيم في بعض الخانات، تُملأ بالصفر تلقائياً
int arr[3][5] = {
    {1, 2, 3, 4, 5},
    {6, 7},           // باقي العناصر ستكون صفر
    {11, 12, 13, 14, 15}
};
\`\`\`

### إدخال وإخراج المصفوفات الثنائية
\`\`\`cpp
// إدخال عناصر المصفوفة (صف تلو الآخر)
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 5; j++) {
        cin >> arr[i][j];
    }
}

// إدخال عناصر المصفوفة (عمود تلو الآخر)
for (int j = 0; j < 5; j++) {
    for (int i = 0; i < 3; i++) {
        cin >> arr[i][j];
    }
}

// طباعة عناصر المصفوفة
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 5; j++) {
        cout << arr[i][j] << " ";
    }
    cout << endl;  // لبدء سطر جديد بعد كل صف
}
\`\`\`

<div dir="ltr">
<h3>Output</h3>
<pre>
<code>
// إذا تم الإدخال صف صف
1 2 3 4 5
6 7 8 9 10
11 12 13 14 15
</code>
<code>
// إذا تم الإدخال عامود عامود
1 4 7 10 13
2 5 8 11 14
3 6 9 12 15
</code>
</pre>
</div>

## عمليات خاصة بالمصفوفات الثنائية

### طباعة عناصر القطر الرئيسي
القطر الرئيسي في المصفوفة هو العناصر التي تقع فيها رقم الصف يساوي رقم العمود (\`i = j\`).

\`\`\`cpp
// تعريف المصفوفة
int arr[4][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12},
    {13, 14, 15, 16}
};

// طباعة عناصر القطر الرئيسي
for (int i = 0; i < n; i++) {
  cout << arr[i][i] << " ";
}
\`\`\`

<div dir="ltr">
  <h3>Output</h3>
  <pre>
    <code>
1 6 11 16
    </code>
  </pre>
</div>

### طباعة عناصر القطر الثانوي
القطر الثانوي في المصفوفة هو العناصر التي يكون فيها مجموع رقم الصف ورقم العمود يساوي (\`rows - 1\`) أي <br> (\`i + j = n - 1\`).

\`\`\`cpp
// تعريف المصفوفة
int arr[4][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12},
    {13, 14, 15, 16}
};

// طباعة عناصر القطر الثانوي
for (int i = 0; i < n; i++) {
  cout << arr[i][n-1-i] << " ";
}
\`\`\`

<div dir="ltr">
  <h3>Output</h3>
  <pre>
    <code>
4 7 10 13
    </code>
  </pre>
</div>

### طباعة عناصر المثلث فوق القطر الرئيسي
هي العناصر التي يكون فيها رقم العمود أكبر من رقم الصف <br>(\`j > i\`).

\`\`\`cpp
// تعريف المصفوفة
int arr[4][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12},
    {13, 14, 15, 16}
};

// طباعة عناصر المثلث فوق القطر الرئيسي
for (int i = 0; i < n; i++) {
  for (int j = i + 1; j < n; j++) {
    cout << arr[i][j] << " ";
  }
  cout << endl;  // لبدء سطر جديد بعد كل صف
}
\`\`\`

<div dir="ltr">
  <h3>Output</h3>
  <pre>
    <code>
2 3 4
  7 8
    12
    </code>
  </pre>
</div>

### طباعة عناصر المثلث تحت القطر الرئيسي
هي العناصر التي يكون فيها رقم العمود أقل من رقم الصف <br>(\`j < i\`).

\`\`\`cpp
// تعريف المصفوفة
int arr[4][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12},
    {13, 14, 15, 16}
};

// طباعة عناصر المثلث تحت القطر الرئيسي
for (int i = 0; i < n; i++) {
  for (int j = 0; j < i; j++) {
    cout << arr[i][j] << " ";
  }
  cout << endl;
}
\`\`\`

<div dir="ltr">
  <h3>Output</h3>
  <pre>
    <code>
5
9 10
13 14 15
    </code>
  </pre>
</div>

### طباعة عناصر المثلث فوق القطر الثانوي
هي العناصر التي يكون فيها مجموع رقم الصف ورقم العمود أقل من (\`rows- 1\`) أي (\`i + j < n - 1\`).

\`\`\`cpp
// تعريف المصفوفة
int arr[4][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12},
    {13, 14, 15, 16}
};

// طباعة عناصر المثلث فوق القطر الثانوي
for (int i = 0; i < n - 1; i++) {
  for (int j = 0; j < n - 1 - i; j++) {
    cout << arr[i][j] << " ";
  }
  cout << endl;
}
\`\`\`

<div dir="ltr">
  <h3>Output</h3>
  <pre>
    <code>
1 2 3
5 6
9
    </code>
  </pre>
</div>

### طباعة عناصر المثلث تحت القطر الثانوي
هي العناصر التي يكون فيها مجموع رقم الصف ورقم العمود أكبر من (\`rows - 1\`) أي (\`i + j > n - 1\`).

\`\`\`cpp
// تعريف المصفوفة
int arr[4][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12},
    {13, 14, 15, 16}
};

// طباعة عناصر المثلث تحت القطر الثانوي
for (int i = 0; i < n; i++) {
  for (int j = n - i; j < n; j++) {
    cout << arr[i][j] << " ";
  }
  cout << endl;
}
\`\`\`

<div dir="ltr">
  <h3>Output</h3>
  <pre>
    <code>
      8
   11 12
14 15 16
    </code>
  </pre>
</div>

> [warning]
> ### ملاحظات هامة
> - لا يمكن استخدام حلقة واحدة لإدخال جميع عناصر المصفوفة الثنائية (إلا في حالات خاصة).
> - يجب الانتباه لترتيب إدخال العناصر (صف تلو الآخر أو عمود تلو الآخر) حسب متطلبات المسألة.
`
    },
    {
        id: 5,
        title: "التوابع ١",
        hasExercises: true,
        content: `
## ما هو التابع؟
---
التابع هو عبارة عن برنامج مصغر يمكن استدعاؤه عدة مرات داخل البرنامج الرئيسي. يتكون التابع من:
- دخل (وسطاء أو parameters).
- مجموعة من التعليمات البرمجية.
- خرج (القيمة التي يعيدها).

## لماذا نستخدم التوابع؟
---
**التوابع تساعدنا على**:<br>
1. إعادة استخدام نفس الشيفرة البرمجية عدة مرات دون تكرارها.<br>
2. تنظيم البرنامج وتقسيمه إلى أجزاء منطقية أصغر.<br>
3. تجنب التكرار وجعل البرنامج أكثر وضوحاً.

## الفرق بين التوابع والحلقات
---
- **الحلقات**: تنفذ مجموعة من التعليمات بشكل متتالي عدة مرات.
- **التوابع**: يمكن تنفيذها بشكل منفصل عند استدعائها (لا يجب أن تكون متتالية).

## كيفية استخدام التابع
---
1. **التعريف**: نعرف التابع فوق الدالة الرئيسية \`main\`.<br>
2. **الاستدعاء**: نستدعي التابع داخل الدالة الرئيسية \`main\`.

## بنية التابع
---
\`\`\`cpp
return_type function_name(parameter 1, parameter 2, ...) {
    // التعليمات البرمجية
    return return_value; // في حال التابع يعيد قيمة
}
\`\`\`

> ### قواعد مهمة:
> - **اسم التابع**: يخضع لنفس شروط أسماء المتغيرات (لا تبدأ بأرقام، لا مسافات، إلخ).
> - **القيمة المعادة**: يمكن أن تكون \`int\`, \`float\`, إلخ... مع استخدام \`return\`.
> - **تابع لا يعيد قيمة**: نستخدم \`void\` وليس بالضرورة استخدام \`return\`.  

## أنواع التوابع:
---
1. **توابع جاهزة**: موجودة ضمن مكتبات اللغة (مثل \`sqrt\` في الرياضيات).<br>
2. **توابع معرفة من المستخدم**: نقوم بتعريفها بأنفسنا.

## الوسطاء (Parameters):
---
- يجب ذكر نوع كل وسيط بجانب اسمه (حتى لو كانت كلها من نفس النوع).
- لا يمكن تسمية وسيطين بنفس الاسم.

## أمثلة عملية
---
### مثال ١: تابع يعيد قيمة (إيجاد العدد الأكبر)

\`\`\`cpp
#include <iostream>
using namespace std;
// تعريف الدالة
int comp(int x, int y) {
    if (x > y)
        return x;
    else
        return y;
}
int main() {
    int x, y;
    // إدخال رقمين
    // فرضاً 8 و 4
    cin >> x >> y;
    // إستدعاء الدالة وطباعة النتيجة
    cout << "The large number is " << comp(x, y);
    return 0;
}
\`\`\`

<div dir="ltr">
  <h3>Output</h3>
  <pre>
    <code>
The large number is 8
    </code>
  </pre>
</div>

**شرح المثال**:

- التابع \`comp\` يستقبل عددين ويقارن بينهما.
- إذا كان العدد الأول أكبر، يعيد العدد الأول وإلا، يعيد العدد الثاني.
- في الدالة الرئيسية، ندخل عددين ثم نستدعي التابع لإيجاد الأكبر وطباعته.

### مثال ٢: تابع لا يعيد قيمة (void)

\`\`\`cpp
#include <iostream>
using namespace std;
// تعريف الدالة
void comp(int x, int y) {
    if (x > y)
        cout << x;
    else
        cout << y;
}
int main() {
    int m, n;
    // إدخال رقمين
    // فرضاً 8 و 4
    cin >> m >> n;
    // إستدعاء الدالة
    comp(m, n);
    return 0;
}
\`\`\`

<div dir="ltr">
  <h3>Output</h3>
  <pre>
    <code>
8
    </code>
  </pre>
</div>

**شرح المثال**:

- التابع \`comp\` يستقبل عددين ويطبع الأكبر مباشرة.
- لاحظ استخدام \`void\` لأن التابع لا يعيد قيمة.
- في الدالة الرئيسية، ندخل عددين ثم نستدعي التابع.

### مثال ٣: تابع بدون وسطاء

\`\`\`cpp
void Hello() {
    cout << "Hello world!";
}
// يمكن استدعاءه كالتالي
Hello();
\`\`\`

<div dir="ltr">
  <h3>Output</h3>
  <pre>
    <code>
Hello world!
    </code>
  </pre>
</div>

## طرق تمرير الوسطاء
---
### 1. التمرير بالقيمة (Call by Value)

\`\`\`cpp
void swapC(int x, int y) {
    int z;
    z = x;
    x = y;
    y = z;
}
int main() {
    int a = 2, b = 5;
    swapC(a, b);
    cout << a << b;
    return 0;
}
\`\`\`

<div dir="ltr">
  <h3>Output</h3>
  <pre>
    <code>
2 5
    </code>
  </pre>
</div>

**شرح المثال**:

- تم تمرير نسخة من القيم \`a\` و \`b\` إلى التابع.
- تم تبديل القيم داخل التابع فقط.
- لم تتغير القيم الأصلية في الدالة الرئيسية.

### ٢. التمرير بالمرجع (Call by Reference)

\`\`\`cpp
void swapR(int &x, int &y) {
    int z;
    z = x;
    x = y;
    y = z;
}
int main() {
    int a = 2, b = 5;
    swapR(a, b);
    cout << a << b;  // سيطبع ٥٢
    return 0;
}
\`\`\`

<div dir="ltr">
  <h3>Output</h3>
  <pre>
    <code>
5 2
    </code>
  </pre>
</div>

**شرح المثال**:

- تم تمرير المتغيرات \`a\` و \`b\` بالمرجع (باستخدام &).
- أي تغيير في \`x\` و \`y\` داخل التابع يؤثر على القيم الأصلية.
- لذلك تم تبديل القيم بنجاح.

> [success]
> ### نصائح
>1. **افهم الفرق بين التابع والبرنامج الرئيسي**: التابع هو جزء صغير نستدعيه عند الحاجة.<br>
>2. **تخيل التابع كآلة حاسبة**: تعطيها مدخلات (وسطاء) وتعطيك مخرجات (القيمة المعادة).<br>
>3. **استخدم أسماء واضحة**: اختر أسماء معبرة للتوابع تصف ما تقوم به.
>4. **انتبه للفرق بين التمرير بالقيمة والتمرير بالمرجع**: 
>    - التمرير بالقيمة: تنشئ نسخة مؤقتة من المتغيرات.
>    - التمرير بالمرجع: تعمل على المتغيرات الأصلية مباشرة.
>5. **لا تنسَ تحديد نوع القيمة المعادة**: \`int\`, \`float\`, \`void\`, إلخ...<br>
>6. **تجنب تكرار الشيفرة**: إذا كنت تستخدم نفس الشيفرة أكثر من مرة، حولها إلى تابع.
`
    },
    {
        id: 6,
        title: "التوابع ٢",
        hasExercises: true,
        content: `
## الوسطاء الافتراضية
---
يمكن تعريف قيم افتراضية للوسطاء، تُستخدم في حالة عدم تمرير قيمة لها عند استدعاء التابع:

\`\`\`cpp
// تعريف تابع مع وسيط افتراضي
int sum(int x, int y, int z = 0) {
    return x + y + z;
}

// استدعاء التابع
cout << sum(5, 3);
cout << sum(5, 3, 2);
\`\`\`

<div dir="ltr">
  <h3>Output</h3>
  <pre>
    <code>
8\n10
    </code>
  </pre>
</div>

> [warning]
> ### ملاحظات عن الوسطاء الافتراضية
> - إذا كان هناك وسيط له قيمة افتراضية، فجميع الوسطاء بعده يجب أن تكون لها قيم افتراضية أيضاً.
> - يمكن استدعاء التابع بعدد أقل من الوسطاء إذا كانت الوسطاء المتبقية لها قيم افتراضية.

## التصريح المسبق عن التوابع
---
\`\`\`cpp
// التصريح عن التابع قبل استخدامه
int multiply(int x, int y);

int main() {
    cout << multiply(5, 3);  // استدعاء التابع قبل تعريفه
    return 0;
}

// تعريف التابع بعد استخدامه
int multiply(int x, int y) {
    return x * y;
}
\`\`\`

<div dir="ltr">
  <h3>Output</h3>
  <pre>
    <code>
15
    </code>
  </pre>
</div>

## التحميل الزائد للتوابع
---
يمكن تعريف عدة توابع بنفس الاسم شرط أن تختلف في عدد أو نوع الوسطاء:
\`\`\`cpp
// تابع لجمع عددين صحيحين
int sum(int x, int y) {
    return x + y;
}

// تابع لجمع ثلاثة أعداد صحيحة
int sum(int x, int y, int z) {
    return x + y + z;
}

// تابع لجمع عددين من نوع float
float sum(float x, float y) {
    return x + y;
}
\`\`\`

> [warning]
> ### ملاحظات عن التحميل الزائد
> - يعتمد اختيار التابع المناسب على عدد ونوع الوسطاء المستخدمة عند الاستدعاء.
> - نوع القيمة المرجعة (return type) ليس جزءاً من توقيع التابع وليس معياراً للتمييز بين التوابع.

## أنواع المتغيرات من حيث نطاق الرؤية
---
### المتغيرات المحلية
- يتم تعريفها داخل التوابع أو داخل نطاق معين \`{}\`.
- يمكن استخدامها فقط داخل النطاق الذي عُرفت فيه.
- تُحذف من الذاكرة عند الخروج من النطاق.
- تُخزن في جزء الذاكرة المسمى Stack (حجم محدود).

### المتغيرات العامة
- يتم تعريفها خارج جميع التوابع.
- يمكن استخدامها من أي مكان في البرنامج.
- تبقى في الذاكرة طوال فترة تنفيذ البرنامج.
- تُخزن في جزء الذاكرة المسمى Heap (حجم أكبر).

**شكل توضيحي**
![array structure](https://ik.imagekit.io/qkzwdg8a3/img-lgv.jpg)

\`\`\`cpp
// متغير عام
int globalVar = 10;

void someFunction() {
    // متغير محلي
    int localVar = 5;
    cout << globalVar; // يمكن الوصول للمتغير العام
    cout << localVar;  // يمكن الوصول للمتغير المحلي
}

int main() {
    cout << globalVar; // يمكن الوصول للمتغير العام
    cout << localVar;  // خطأ! لا يمكن الوصول للمتغير المحلي خارج نطاقه
    return 0;
}
\`\`\`

<div dir="ltr">
  <h3>Output</h3>
  <pre>
    <code>
In function 'int main()':
error: 'localVar' was not declared in this scope
   cout << localVar;
           ^~~~~~~~
    </code>
  </pre>
</div>

### المتغيرات الثابتة
- تُعرّف باستخدام كلمة \`static\`.
- تحتفظ بقيمتها بين استدعاءات التابع.
- تُهيأ مرة واحدة فقط عند أول استدعاء للتابع.
- تُخزن في الـ Stack لكنها لا تُحذف عند الخروج من النطاق.

\`\`\`cpp
void countCalls() {
    static int count = 2;  // تُهيأ مرة واحدة فقط
    count++;
    cout << count << endl;
}

int main() {
    countCalls();
    countCalls();
    countCalls();
    return 0;
}
\`\`\`

<div dir="ltr">
  <h3>Output</h3>
  <pre>
    <code>
3
4
5
    </code>
  </pre>
</div>

## تمرير المصفوفات كوسطاء للتوابع
---
### تمرير المصفوفات الأحادية
\`\`\`cpp
// تعريف تابع يستقبل مصفوفة أحادية
void printArray(int arr[], int length) {
    for (int i = 0; i < length; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

// استدعاء التابع
int numbers[] = {1, 2, 3, 4, 5};
printArray(numbers, 5);
\`\`\`

<div dir="ltr">
  <h3>Output</h3>
  <pre>
    <code>
1 2 3 4 5
    </code>
  </pre>
</div>

### تمرير المصفوفات الثنائية
عند تمرير مصفوفة ثنائية، يجب تحديد عدد الأعمدة:

\`\`\`cpp
// تعريف تابع يستقبل مصفوفة ثنائية
void printMatrix(int matrix[][3], int rows) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < 3; j++) {
            cout << matrix[i][j] << " ";
        }
        cout << endl;
    }
}

// استدعاء التابع
int grid[2][3] = {
  {1, 2, 3}, 
  {4, 5, 6}
};
printMatrix(grid, 2);
\`\`\`

<div dir="ltr">
  <h3>Output</h3>
  <pre>
    <code>
1 2 3
4 5 6
    </code>
  </pre>
</div>

> [warning]
> ### ملاحظات هامة
> - عند تمرير مصفوفة إلى تابع، يتم تمرير مؤشر للعنصر الأول (عنوانها في الذاكرة)، وليس نسخة من المصفوفة.
> - أي تغيير على المصفوفة داخل التابع سيؤثر على المصفوفة الأصلية.
> - يجب دائماً تمرير حجم المصفوفة كوسيط إضافي.
> - في المصفوفات الثنائية، يجب تحديد البعد الثاني (عدد الأعمدة) عند تعريف التابع.
`
    },
    {
        id: 7,
        title: "التوابع العودية",
        hasExercises: true,
        content: `
## ما هي التوابع العودية؟
---
التوابع العودية هي توابع تقوم باستدعاء نفسها. هذا يختلف عن الحالة العادية حيث يمكن لأي تابع أن يستدعي تابعًا آخر.

> ### نقاط مهمة حول التوابع العودية
> - يجب وضع شرط توقف (حالة أساسية) لكسر العودية وإلا سندخل في استدعاءات لا نهائية.
> - الاستدعاءات اللانهائية تؤدي إلى امتلاء ذاكرة الـ stack وحدوث خطأ Runtime.
> - كل استدعاء للتابع العودي يحتفظ بمتغيراته الخاصة في ذاكرة الـ stack.

### كيفية كتابة تابع عودي؟
لكتابة تابع عودي، علينا الإجابة على ثلاثة أسئلة:
1. متى يتوقف التابع؟ (شرط التوقف أو الحالات البسيطة).
2. كيف سيتم الاستدعاء بقيم وسطاء مختلفة (جانب أبسط من المسألة).
3. كيف سيتم تركيب الحل النهائي؟! 

### مثال 1: حساب العاملي
قانون العاملي هو

\`n! = n × (n-1) × (n-2) × ... × 3 × 2 × 1\`

#### الحل التكراري (باستخدام حلقة):
\`\`\`cpp
int factorial(int n) {
    int result = 1;
    for(int i = 1; i <= n; i++) {
        result *= i;
    }
    return result;
}
\`\`\`

#### الحل العودي:
\`\`\`cpp
int factorial(int n) {
    if(n == 0 || n == 1)  // شرط التوقف
        return 1;
    else
        return n * factorial(n - 1);  // استدعاء التابع لحالة أبسط
}

// استدعاء التابع
cout << "Factorial for 3 is " << factorial(3);
\`\`\`

<div dir="ltr">
  <h3>Output</h3>
  <pre>
    <code>
Factorial for 3 is 6
    </code>
  </pre>
</div>

**توضيح استدعاءات العودية للعاملي:**
- \`factorial(3)\` = 3 * \`factorial(2)\` = 3 * 2 = 6
- \`factorial(2)\` = 2 * \`factorial(1)\` = 2 * 1 = 2
- \`factorial(1)\` = 1 (شرط التوقف)

### مثال 2: طباعة الأعداد من 1 إلى n تصاعديًا

#### الحل التكراري:
\`\`\`cpp
void countUp(int n) {
    for(int i = 1; i <= n; i++)
        cout << i << endl;
}
\`\`\`

#### الحل العودي:
\`\`\`cpp
void countUp(int x) {
    if(x > 1) {
        countUp(x-1);
    }
    cout << x << endl;
}

// استدعاء التابع
cout << "Count from 1 to 5\n" << countUp(5);
\`\`\`

<div dir="ltr">
  <h3>Output</h3>
  <pre>
    <code>
Count from 1 to 5
1\n2\n3\n4\n5
    </code>
  </pre>
</div>

**توضيح استدعاءات العودية لطباعة الأعداد تصاعديًا:**
- \`countUp(3)\` يستدعي \`countUp(2)\` ثم يطبع 3
- \`countUp(2)\` يستدعي \`countUp(1)\` ثم يطبع 2
- \`countUp(1)\` يطبع 1 (ليس هناك استدعاء آخر)

### مثال 3: طباعة الأعداد من n إلى 1 تنازليًا

\`\`\`cpp
void countDown(int x) {
    if(x == 1)
        cout << x;
    else {
        cout << x << endl;
        countDown(x-1);
    }
}
\`\`\`

أو بطريقة أخرى:

\`\`\`cpp
void countDown(int x) {
    cout << x << endl;
    if(x > 1)
        countDown(x-1);
}

// استدعاء التابع
cout << "Count from 5 to 1\n" << countDown(5);
\`\`\`

<div dir="ltr">
  <h3>Output</h3>
  <pre>
    <code>
Count from 5 to 1
5\n4\n3\n2\n1
    </code>
  </pre>
</div>

### مثال 4: حساب القاسم المشترك الأكبر (GCD)

خوارزمية إقليدس: طرح العددين دائمًا الكبير من الصغير ووضع النتيجة مكان الكبير.

#### الحل التكراري:
\`\`\`cpp
int gcd(int x, int y) {
    while(x != y) {
        if(x > y)
            x = x - y;
        else
            y = y - x;
    }
    return x;
}
\`\`\`

#### الحل العودي:
\`\`\`cpp
int gcd(int x, int y) {
    if(x == y)
        return x;
    else if(x > y)
        return gcd(x-y, y);
    else
        return gcd(y-x, x);
}

// استدعاء التابع
cout << "GCD for 4 and 8 is " << gcd(4, 8);
\`\`\`

<div dir="ltr">
  <h3>Output</h3>
  <pre>
    <code>
GCD for 5 and 8 is 4
    </code>
  </pre>
</div>

> [warning]
> ### ملاحظة مهمة:
> الحل التكراري عادة أسرع من الحل العودي؛ لأن الحل العودي يحتاج إلى ذاكرة إضافية للاستدعاءات المتكررة وقد يؤدي إلى امتلاء stack إذا كان عدد الاستدعاءات كبيرًا.

> [success]
> ### خلاصة ونصائح
> 1. تأكد دائمًا من وجود شرط توقف واضح.
> 2. تحقق من أن كل استدعاء يقرب المشكلة من الحل الأساسي.
> 3. استخدم الحلول التكرارية بدلاً من العودية للمهام البسيطة أو التي تتطلب كفاءة عالية.
`
    },
    {
        id: 8,
        title: "السجلات",
        hasExercises: true,
        content: `
## مفهوم السجلات:
---
السجلات هي طريقة لتجميع مجموعة من البيانات مختلفة النوع تحت مسمى واحد. تختلف عن المصفوفة التي تحوي عناصر من نوع واحد فقط.

**شكل توضيحي**
![array structure](https://ik.imagekit.io/qkzwdg8a3/img-ssr.jpg)

- الصندوق الكبير يمثل السجل الكامل (struct) ويشار إليه بـ "big box".
- الصناديق الصغيرة داخله تمثل الحقول المختلفة في السجل وتشار إليها بـ "small box".
- الحقول في هذا السجل هي:
   - year (السنة).
   - phone (رقم الهاتف).
   - name (الاسم).
- يشار إلى متغير السجل باسم "x".
- كل هذا يتم تخزينه في ذاكرة الوصول العشوائي (RAM memory).

### تعريف السجل:
\`\`\`cpp
struct struct_name {
    variable_type variable_name;
    // ... المزيد من الحقول
};
\`\`\`

### مثال تطبيقي: برنامج لتسجيل بيانات الطلاب

\`\`\`cpp
struct student {
    string name;
    string phone;
    int year;
};

int main() {
    student x;  // إنشاء متغير من نوع student
    x.name = "Ahmad";  // تعيين قيمة لحقل الاسم
    x.phone = "123456789";
    x.year = 2;
    
    // الوصول إلى قيم الحقول
    cout << x.name << ", " << x.year << " years\n";
    cout << "Phone number: " << x.phone;
    return 0;
}
\`\`\`

<div dir="ltr">
  <h3>Output</h3>
  <pre>
    <code>
Ahmad, 2 years
Phone number: 123456789
    </code>
  </pre>
</div>

### استخدام مصفوفة من السجلات:

\`\`\`cpp
struct student {
    string name;
    string phone;
    int year;
};

int main() {
    student arr[1000];  // مصفوفة تحوي 1000 طالب
    arr[0].name = "Ahmad";
    arr[0].year = 2;
    arr[1].name = "Khaled";
    arr[1].year = 3;
    return 0;
}
\`\`\`

### مثال متقدم: تخزين علامات الطلاب لمقررات دراسية

\`\`\`cpp
struct student {
    string name;
    int year;
    int marks[6];  // مصفوفة لتخزين علامات 6 مواد
};

int main() {
    student arr[1000];
    arr[0].name = "Mohamed";
    arr[0].year = 1;
    // إدخال العلامات للطالب الأول
    for(int i = 0; i < 6; i++)
        cin >> arr[0].marks[i];
    return 0;
}
\`\`\`

### توابع تتعامل مع السجلات:

\`\`\`cpp
void print(student x) {
    cout << "Name: " << x.name << ", Year: " << x.year << endl;
    cout << "Marks: ";
    for(int i = 0; i < 6; i++)
        cout << x.marks[i] << " ";
    cout << endl;
}

int main() {
    student s;
    s.name = "Ali";
    s.year = 3;
    for(int i = 0; i < 6; i++)
        s.marks[i] = 80 + i;
    print(s);  // استدعاء التابع وإرسال السجل إليه
    return 0;
}
\`\`\`

<div dir="ltr">
  <h3>Output</h3>
  <pre>
    <code>
Name: Ali, Year: 3
Marks: 80 81 82 83 84 85
    </code>
  </pre>
</div>

### السجلات المتداخلة
يمكن أن يكون أحد حقول السجل هو سجل آخر:

\`\`\`cpp
struct birthday {
    int year;
    int month;
    int day;
};

struct student {
    string name;
    birthday date;  // حقل من نوع سجل آخر
};

int main() {
    student x;
    // فرضاً Mohamed
    cin >> x.name;
    // فرضاً 1997, 02, 21
    cin >> x.date.year >> x.date.month >> x.date.day;
    cout << "Name: " << x.name << endl;
    cout << "Birth date: " << x.date.day << "/" << x.date.month << "/" << x.date.year;
    return 0;
}
\`\`\`

<div dir="ltr">
  <h3>Output</h3>
  <pre>
    <code>
Name: Mohamed
Birth date: 21/02/1997
    </code>
  </pre>
</div>

> [success]
> ### خلاصة ونصائح
> 1. استخدم السجلات عندما تحتاج إلى تجميع بيانات مختلفة النوع تحت اسم واحد.
> 2. يمكن إنشاء مصفوفات من السجلات للتعامل مع مجموعات كبيرة من البيانات.
> 3. يمكن تداخل السجلات لتمثيل بيانات أكثر تعقيدًا.
> 4. استخدم التوابع للتعامل مع السجلات (إدخال، طباعة، معالجة) بطريقة منظمة.
    `
    }
];
